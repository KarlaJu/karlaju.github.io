<!DOCTYPE html>
<html lang="zn-Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="Karla Jurado">
  <meta name="description" content="Introducción a Swift Contenido 1.- Variables
2.- Constantes
3.- Tipos de datos
 3.1.- Entero
 3.2.- Cadenas
 3.3.- Flotante
 3.4.- Double
  4.- Funciones
5.- Modelado de datos
 5.1.- Tuplas
 5.1.1.- Switch
 5.2.- Opcionales
 5.2.1.- IF LET
 5.2.2.- Casos particulares con opcionales
 5.3.- Arreglos
 5.4.- Enums
 5.4.1.- Switch con enums
 4.5.- Diccionarios
 5.6.- Conjuntos
  Variables La declaración de una variable, puede ser de dos formas:
var number: Int var secondNumber = 8 // Inferencia de tipos  Constantes La declaración de una contante, una vez que la variable se declare con let, su valor ya no puede cambiar:
let number = 8   Una recomendación es siempre utilizar let. Existirán casos donde no se pueda utilizar, pero siempre es mejor utilizar let.
 Tipos de datos Si no se le indica el tipo de dato a la variable, el compilador lo tomará de acuerdo a su valor.
Entero El valor por defecto que tiene un entero es de 64 bits.
var number: Int = 10 let number: Int let number: Int8 = 120 //Se puede indicar el valor máximo que usará   Se debe tener cuidado cuando se indique el valor máximo que utilizará porque si rebasa ese valor puede causar un overflow.">
  
  <meta property="og:title" content="Introducción a Swift" />
<meta property="og:description" content="Introducción a Swift Contenido 1.- Variables
2.- Constantes
3.- Tipos de datos
 3.1.- Entero
 3.2.- Cadenas
 3.3.- Flotante
 3.4.- Double
  4.- Funciones
5.- Modelado de datos
 5.1.- Tuplas
 5.1.1.- Switch
 5.2.- Opcionales
 5.2.1.- IF LET
 5.2.2.- Casos particulares con opcionales
 5.3.- Arreglos
 5.4.- Enums
 5.4.1.- Switch con enums
 4.5.- Diccionarios
 5.6.- Conjuntos
  Variables La declaración de una variable, puede ser de dos formas:
var number: Int var secondNumber = 8 // Inferencia de tipos  Constantes La declaración de una contante, una vez que la variable se declare con let, su valor ya no puede cambiar:
let number = 8   Una recomendación es siempre utilizar let. Existirán casos donde no se pueda utilizar, pero siempre es mejor utilizar let.
 Tipos de datos Si no se le indica el tipo de dato a la variable, el compilador lo tomará de acuerdo a su valor.
Entero El valor por defecto que tiene un entero es de 64 bits.
var number: Int = 10 let number: Int let number: Int8 = 120 //Se puede indicar el valor máximo que usará   Se debe tener cuidado cuando se indique el valor máximo que utilizará porque si rebasa ese valor puede causar un overflow." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/swift-intro/" /><meta property="article:published_time" content="2019-10-20T21:45:28-05:00"/>
<meta property="article:modified_time" content="2019-10-20T21:45:28-05:00"/><meta property="og:see_also" content="/post/vim/" /><meta property="og:see_also" content="/post/react-intro/" />



  <title>
  
       Introducción a Swift | Karla Jurado 
  
  </title>

  <link rel="canonical" href="/post/swift-intro/">

  
  

  
  <link href="/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="/css/font.css" rel="stylesheet"> 
    
  
  <link href="/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
      href="/img/zheng.png"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="/">
          
        <img class="avatar" src="/img/zheng.png" style="width: 40px!important;height: auto;"  class="d-inline-block align-top" alt="" >
        
        <strong> Karla Jurado</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="/">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('/img/header-slides/abstract-art-canvas-288099.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="/">
          
            <img class="pull-right avatar avatar-md" src="/img/profile.jpg" alt="" >
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="/">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>Karla Jurado</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="https://github.com/KarlaJu" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            

            

            

            
                <a href="https://twitter.com/KarlaJuJ" target="_blank" rel="noopener"><i class="fab fa-twitter pr-1" aria-hidden="true"></i></a>
            

            
                <a href="https://www.instagram.com/acoralay/" target="_blank" rel="noopener"><i class="fab fa-instagram pr-1" aria-hidden="true"></i></a>
            
    
            
    
        
            
                <a href="mailto:karla@makingdevs.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="container pr-5">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="/categories/swift"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> Swift </a></li>
      
    
    
      
        <li><a href="/series/technology"><i class="fas fa-bookmark pr-1" aria-hidden="true"></i>technology</a></li>
      
    
  </ul>

  <div class="px-4 post-heading">Introducción a Swift</div>

  <ul class="post-meta li-x mt-1">
    
      <li>Oct 20, 2019</li>
    

    
      <li class="middot"></li>
      <li>16 minutes read</li>
    
  </ul>
  

</div>


          <div class="post-content markdown">
            

<h2 id="introducción-a-swift">Introducción a Swift</h2>

<h3 id="contenido">Contenido</h3>

<p><a href="#variables">1.- Variables</a></p>

<p><a href="#constantes">2.- Constantes</a></p>

<p><a href="#tipos-de-datos">3.- Tipos de datos</a></p>

<ul>
<li><p><a href="#entero">3.1.- Entero</a></p></li>

<li><p><a href="#cadenas">3.2.- Cadenas</a></p></li>

<li><p><a href="#flotante">3.3.- Flotante</a></p></li>

<li><p><a href="#double">3.4.- Double</a></p></li>
</ul>

<p><a href="#funciones">4.- Funciones</a></p>

<p><a href="#modelado-de-datos">5.- Modelado de datos</a></p>

<ul>
<li><p><a href="#tuplas">5.1.- Tuplas</a></p></li>

<li><p><a href="#switch">5.1.1.- Switch</a></p></li>

<li><p><a href="#opcionales">5.2.- Opcionales</a></p></li>

<li><p><a href="#if-let">5.2.1.- IF LET</a></p></li>

<li><p><a href="#casos-particulares-con-opcionales">5.2.2.- Casos particulares con opcionales</a></p></li>

<li><p><a href="#arreglos">5.3.- Arreglos</a></p></li>

<li><p><a href="#enums">5.4.- Enums</a></p></li>

<li><p><a href="#switch-con-enums">5.4.1.- Switch con enums</a></p></li>

<li><p><a href="#diccionarios">4.5.- Diccionarios</a></p></li>

<li><p><a href="#conjuntos">5.6.- Conjuntos</a></p></li>
</ul>

<h3 id="variables">Variables</h3>

<p>La declaración de una variable, puede ser de dos formas:</p>

<pre><code class="language-swift">var number: Int
var secondNumber = 8 // Inferencia de tipos
</code></pre>

<h3 id="constantes">Constantes</h3>

<p>La declaración de una contante, una vez que la variable se declare con let, su valor ya no puede cambiar:</p>

<pre><code class="language-swift">let number = 8
</code></pre>

<blockquote>
<p>Una recomendación es siempre utilizar let. Existirán casos donde no se pueda utilizar, pero siempre es mejor utilizar let.</p>
</blockquote>

<h3 id="tipos-de-datos">Tipos de datos</h3>

<p>Si no se le indica el tipo de dato a la variable, el compilador lo tomará de acuerdo a su valor.</p>

<h4 id="entero">Entero</h4>

<p>El valor por defecto que tiene un entero es de 64 bits.</p>

<pre><code class="language-swift">var number: Int = 10
let number: Int
let number: Int8 = 120 //Se puede indicar el valor máximo que usará
</code></pre>

<blockquote>
<p>Se debe tener cuidado cuando se indique el valor máximo que utilizará porque si rebasa ese valor puede causar un overflow.</p>
</blockquote>

<p>En este caso se genera un error en tiempo de ejecución, el compilador al usar &lsquo;y&rsquo; y saber qué es de tipo Int8, le pone el mismo tipo de dato a &lsquo;z&rsquo;. Pero al ejecutarse la variable rebasa su valor máximo.</p>

<pre><code class="language-swift">let y: Int8 = 120
let z = y + 10 // Genera un error de ejecución, al compilar se le asigna un tipo de datos Int8 a la variable
let z = y &amp;+ 10 // El &amp; indica que swift se comporte como C, genera un overflow pero el resultado es -126
</code></pre>

<p>Ponemos imprimir los valores máximos y mínimos de cada entero:</p>

<pre><code class="language-swift">print(&quot;El valor máximo de Int es \(Int.max).&quot;) //Imprime: 9223372036854775807
print(&quot;El valor mínimo de Int es \(Int.min).&quot;) //Imprime: -9223372036854775808
print(&quot;El valor máximo de UInt es \(UInt.max).&quot;) //Imprime: 18446744073709551615
print(&quot;El valor mínimo de UInt es \(UInt.min).&quot;) //Imprime: 0
print(&quot;El valor máximo de Int8 es \(Int8.max).&quot;) //Imprime: 127
print(&quot;El valor máximo de Int16 es \(Int16.max).&quot;) //Imprime: 32767
print(&quot;El valor máximo de Int32 es \(Int32.max).&quot;) //Imprime: 2147483647
print(&quot;El valor máximo de Int64 es \(Int64.max).&quot;) //Imprime: 9223372036854775807
</code></pre>

<h4 id="cadenas">Cadenas</h4>

<pre><code class="language-swift">let myString: String = &quot;Mi cadena&quot;
let myString2 = &quot;Mi ca\u{301}dena&quot; //Tiene soporte de unicode
let myString3 = &quot;Mi cádena&quot; //Pero también funciona así
</code></pre>

<p>Algunas funciones que se pueden hacer con las cadenas:</p>

<pre><code class="language-swift">//En este caso no cuenta el acento como un caracter más
myString.count //imprime: 9
myString2.count //imprime: 9

//De esta manera el unicode lo separa y nos regresa ambos caracteres separados
myString2.unicodeScalars.count //imprime: 10

//Estructuras de control

//Lo que devuelve indices es un iterador
for index in myString2.indices {
  print(&quot;La salida es: \(myString2[index])&quot;)
}

//Igualdad
//La igualdad será de contenido, no compara que sea exactamente el mismo objeto
if myString2 == myString3 {
  print(&quot;Son iguales&quot;)
}
</code></pre>

<h4 id="flotante">Flotante</h4>

<p>Los flotantes son de 32 bits.</p>

<pre><code class="language-swift">var myfloat: Float = 100.3
let myfloat2: Float
</code></pre>

<h4 id="double">Double</h4>

<p>Los double son de 64 bits.</p>

<pre><code class="language-swift">var myDouble: Double = 1.1
let myDouble2: Double
</code></pre>

<p><strong>Se debe tener en cuenta que el valor de los decimales se guarda en notación científica, al momento de regresar de la notación se pierde precisión.</strong></p>

<blockquote>
<p>Por otro lado nunca se deben validar si son iguales los doubles, porque al guardarse en notación científica muy difícilmente cuadran.</p>
</blockquote>

<pre><code class="language-swift">print(&quot;myDouble + 0.1 es \(myDouble + 0.1)&quot;) //imprime: 1.2000000000000002
if myDouble + 0.1 == 1.2 {
  print(&quot;Son iguales&quot;) // Nunca entra
}
</code></pre>

<h3 id="funciones">Funciones</h3>

<p>Invocación y declaración de una función sin parámetros:</p>

<pre><code class="language-swift">func myfunction() {
  print(&quot;Hola esta es mi función&quot;)
}
myfunction()
</code></pre>

<p>Invocación y declaración de una función con parámetros:</p>

<pre><code class="language-swift">func myfunction(person: String) {
  print(&quot;Hola \(persona)&quot;)
}

//Se debe indicar el nombre del parámetro a mandar
myfunction(person: &quot;Kara&quot;)
</code></pre>

<p>Si se quiere evitar el nombre del parámetro se tiene que colocar un guión bajo en la función.</p>

<pre><code class="language-swift">func myfunction(_ person: String) {
  print(&quot;Hola \(person)&quot;)
}

myfunction(&quot;Karla&quot;)
</code></pre>

<blockquote>
<p>Es más recomendable usar siempre el nombre del parámetro para que el código sea entendible.</p>
</blockquote>

<p>Swift soporta varios parámetros y puede recibir varios indefinidos, indicados con los 3 puntos:</p>

<pre><code class="language-swift">//La función regresa un arreglo
func myfunction(people: String ...) {
  print(&quot;Hola \(people)&quot;)
}

myfunction(people: &quot;Robert&quot;, &quot;Juan&quot;) //Imprime: &quot;Hola [&quot;Robert&quot;, &quot;Juan&quot;]&quot;
</code></pre>

<p>Y en este caso se puede colocar un for para iterar el arreglo:</p>

<pre><code class="language-swift">func myfunction(people: String ...) {
  for person in people{
    print(&quot;Hola \(person)&quot;)
  }
}

myfunction(people: &quot;Karla&quot;, &quot;Juan&quot;)
</code></pre>

<p>Una función con más de un parámetro:</p>

<pre><code class="language-swift">func myfunction(person: String, greeting: String) {
  print(&quot;Hola \(person), \(greeting)&quot;)
}

myfunction(person: &quot;Samuel&quot;, greeting: &quot;buenos días&quot;) //Imprime: &quot;Hola Samuel, buenos días&quot;
</code></pre>

<p>Valores por defecto en una función:</p>

<pre><code class="language-swift">func myfunction(person: String = &quot;Susan&quot;) {
  print(&quot;Hola \(person)&quot;)
}

myfunction(person: &quot;Tomás&quot;) //Imprime: &quot;Hola Tomás&quot;
myfunction() //Imprime: &quot;Hola Susan&quot;
</code></pre>

<p>Indicar valores de retorno:</p>

<pre><code class="language-swift">func myfunction(person: String = &quot;Dante&quot;) -&gt; String {
  return &quot;Saludos a \(person)&quot;
}

let person = myfunction(person: &quot;Raúl&quot;)
myfunction() //Imprime: &quot;Saludos a Dante&quot;
person //Imprime: &quot;Saludos a Raúl&quot;
</code></pre>

<p>Funciones para incrementar valores a un entero:</p>

<pre><code class="language-swift">let firstNumber = 10
let secondNumber: Int = firstNumber.advanced(by: 1) //Permite incrementar por en n número
print(&quot;\(secondNumber)&quot;) //Imprime: &quot;11&quot;
</code></pre>

<p>Se recomienda tener cuidado con este tipo de funciones ya que podrían ser opcionales.</p>

<pre><code class="language-swift">let firstNumber: Int? = 10
let secondNumber: Int = firstNumber!.advanced(by: 1) //Se tiene que forzar a sacar el valor con el signo de exclamación
print(&quot;\(secondNumber)&quot;) //Imprime: &quot;11&quot;
</code></pre>

<h3 id="modelado-de-datos">Modelado de datos</h3>

<h4 id="tuplas">Tuplas</h4>

<p>Declaración de las tuplas y forma de acceder a una tupla sin descripción:</p>

<pre><code class="language-swift">let errorCode = (404, &quot;Not Found&quot;)
print(errorCode.0) //imprime: 404
</code></pre>

<p>Forma de agregar nombre a las tuplas:</p>

<pre><code class="language-swift">let errorCode2 = (code: 404, description: &quot;Not Found&quot;)
print(errorCode2.description) //imprime: Not Found
</code></pre>

<p>Asignación de variables con Pattern Matching de una tupla:</p>

<pre><code class="language-swift">//Funciona como una afirmación
//Lo que esta del lado izquierdo es igual a lo que tengo del lado derecho
//Se de-estructura para poder extraer valores

let (code, message) = errorCode
print(&quot;\(code) : \(message)&quot;) //imprime: 404 : Not Found

//De esta manera no importa recuperar el primer elemento, el único que importa es el segundo
let (_, message2) = errorCode
let errorCode3 = (404, &quot;Not found&quot;, &quot;Otro mensaje&quot;)
let (_,_,message3) = errorCode3
print(message3) //Imprime: Otro mensaje
</code></pre>

<h3 id="switch">Switch</h3>

<p>No importa qué tipo de dato sea, switch lo soporta.</p>

<p>Lleva break por defecto, así que no es necesario indicarlo.</p>

<pre><code class="language-swift">let personaje: String = &quot;Lobo estepario&quot;
switch personaje {
  case &quot;Caballero&quot;:
    print(&quot;El personaje \(personaje) es un caballero&quot;)
  case &quot;Mago&quot;:
    print(&quot;El personaje \(personaje) es un Mago&quot;)
  //Si personaje asignado tiene prefijo 'lobo' y el sufijo 'pario' se asigne a la variable
  case let unPersonaje where unPersonaje.hasPrefix(&quot;Lobo&quot;) &amp;&amp; unPersonaje.hasSuffix(&quot;pario&quot;):
    print(&quot;Wow! El personaje \(personaje) es un Lobo&quot;)
  default:
    print(&quot;Este no es un personaje del juego&quot;)
}
</code></pre>

<blockquote>
<p>En la medida de lo posible, evitar poner default en el switch. Debido a que en ocasiones dentro del default no se declara ninguna acción y se vuelve un problema cuando la aplicación no manda ningún error.</p>

<p>Se recomienda manejar todos los casos y no colocar default.</p>
</blockquote>

<p>El switch soporta rangos:</p>

<pre><code class="language-swift">var numero = 5
switch numero {
  case 0...5:
    numero += 1
    fallthrough //Realizará las acciones y seguirá para entrar en el siguiente caso si es que cumple
  case 6..&lt;10:
    numero *= 1
  case 11:
    print(&quot;Hola&quot;)
    break
  default:
    numero += 1
    print(numero)
}

</code></pre>

<h3 id="opcionales">Opcionales</h3>

<p>En swift las variables no pueden ser nulas. El proyecto no compila sí tiene valores nulos.</p>

<pre><code class="language-swift">var x2: Int
x2 + 1 // x2 no esta declarada, es nula. Y por lo tanto no compila
</code></pre>

<p>De esta manera se declaran las variables opcionales en swift:</p>

<pre><code class="language-swift">var x3: Int? // De esta manera se indica que la variable puede ser nula
x3 = 1
x3 = nil
</code></pre>

<p>Si no se indica que puede ser nula, la aplicación no compilará.</p>

<pre><code class="language-swift">var x4: Int
x4 = 1
x4 = nil //Error de compilación
</code></pre>

<p>De esta manera, es más visual que la variable puede ser nula. Cuando la variable es declarada como posible nula, es necesario forzar a sacar el valor de la variable.</p>

<pre><code class="language-swift">var f: Float? = 1.0
let flotante = f! + 1.9 //El signo de admiración es para forzar a sacar valor
</code></pre>

<blockquote>
<p>Se recomiendo evitar los opcionales siempre</p>
</blockquote>

<h5 id="if-let">IF LET</h5>

<p>En caso de realmente necesitar usar una variable que tal vez sea nula. La mejor forma de manejarla es con un if let. Si la variable es nula, no hará nada con la variable.</p>

<pre><code class="language-swift">if let x = f {
  print(&quot;Todo bien \(x+1)&quot;) //También se puede quedar con el if, sin la necesidad de usar else
} else {
  print(&quot;El opcional no tiene valor&quot;)
}
</code></pre>

<p>Para evitar tener tantos if let anidados como en el siguiente ejemplo:</p>

<pre><code class="language-swift">var cadenaOpcional: String? = &quot;10&quot;
if let s = cadenaOpcional {
  if let i = Int(s) { // Para evitar tener tantos if anidados
  print(&quot;El entero es \(i)&quot;)
  }
}
</code></pre>

<p>Se puede poner una coma y poner varias validaciones en la misma linea.</p>

<pre><code class="language-swift">if let s = cadenaOpcional, let i = Int(s) { //Si es necesario que lleve las llaves
  print(&quot;Cadena es \(s); el entero es \(i)&quot;) //Imprime: Cadena es 10; el entero es 10
}
</code></pre>

<h4 id="casos-particulares-con-opcionales">Casos particulares con opcionales</h4>

<p>En el caso de que un opcional venga vacío, se le podrá asignar un valor por defecto, como en este caso: cero.</p>

<pre><code class="language-swift">let number: Int? = nil
let secondNumber: Int = number?.advanced(by: 1) ?? 0
print(&quot;\(secondNumber)&quot;) //Imprime: &quot;0&quot;
</code></pre>

<p>En el caso de algunas funciones como es &lsquo;first&rsquo;, devuelven valores opcionales así que se debe forzar para que no devuelva un valor opcional.</p>

<pre><code class="language-swift">//Indicando el tipo se forza para que no devuleva un opcional
var favoriteBooks: [String] = []

//De esta manera controlamos si el arreglo viene vacío
let value: String = favoriteBooks.first ?? &quot;Programming swift&quot;
</code></pre>

<p>Si no se indicara el valor de la variable, por defecto &lsquo;first&rsquo; devolvería un String opcional.</p>

<pre><code class="language-swift">//En el caso de venir vacio el arreglo regresaría un nil la variable
let value = favoriteBooks.first
</code></pre>

<h3 id="arreglos">Arreglos</h3>

<pre><code class="language-swift">var librosFavoritos1: [String] = [&quot;Aprende Swift en 3 segundos&quot;,
&quot;Elm para principiantes&quot;,
&quot;Crea sitios increíbles con Elixir&quot;]

var librosFavoritos = [&quot;Aprende Swift en 3 segundos&quot;,
&quot;Elm para principiantes&quot;,
&quot;Crea sitios increíbles con Elixir&quot;] //Inferencia de tipos
</code></pre>

<p>Algunas funciones con arreglos:</p>

<pre><code class="language-swift">librosFavoritos.count //Imprime: 3
librosFavoritos.first //Imprime: Aprende Swift en 3 segundos
librosFavoritos.last //Imprime: Crea sitios increibles con Elixir
librosFavoritos[1] //Imprime: Elm para principiantes
librosFavoritos.append(&quot;Code complete&quot;) //Imprime: [&quot;Aprende Swift en 3 segundos&quot;, &quot;Elm para principiantes&quot;, &quot;Crea sitios increibles con Elixir&quot;, &quot;Code complete&quot;]
librosFavoritos[2] //Imprime: Crea sitios increíbles con Elixir
librosFavoritos.insert(&quot;The art of unix programming&quot;, at: 2) //Imprime: [&quot;Aprende Swift en 3 segundos&quot;, &quot;Elm para principiantes&quot;, &quot;The art of unix programming&quot;, &quot;Crea sitios increíbles con Elixir&quot;, &quot;Code complete&quot;]
librosFavoritos[2] //Imprime: The art of unix programming
librosFavoritos.remove(at: 3) //Imprime: Crea sitios increíbles con Elixir
</code></pre>

<p>Iterar arreglos:</p>

<pre><code class="language-swift">for libro in librosFavoritos {
  print(libro)
}

//enumerated devuelve un conjunto de tuplas
//Se hace un pattern matching con la tupla
for (indice, libro) in librosFavoritos.enumerated() {
  print(&quot;\(indice + 1) : \(libro)&quot;)
}
</code></pre>

<h3 id="enums">Enums</h3>

<p>Con los enums se puede controlar los únicos valores que puede tener la variable:</p>

<pre><code class="language-swift">enum Dia {
  case Lunes
  case Martes
  case Miércoles
  case Jueves
  case Viernes
  case Sabado
}

//Restringo el tipo de dato, pero no el valor. En este caso el tipo de dato es String, el tipo de dato es dia.
//El valor se puede cambiar simplemente con .valor del enum

var nombre: String
var diaSemana = Dia.Lunes
diaSemana = .Jueves
</code></pre>

<h4 id="switch-con-enums">Switch con enums</h4>

<p>El switch tiene que ser exhaustivo y cubrir todos los casos. Con el Enum, se controla los únicos valores que puede tener la variable.</p>

<p>Si se coloca un default incluso contemplando todos los casos, el compilador mandará un mensaje de que nunca entrará a ese caso porque la variable nunca tendrá ese valor.</p>

<pre><code class="language-swift">switch diaSemana {
  case .Lunes:
    print(&quot;Otra vez a trabajar&quot;)
  case .Martes:
    print(&quot;Ya quiero que acabe la semana&quot;)
  case .Miércoles:
    print(&quot;Apenas vamos a la mitad&quot;)
  case .Jueves:
    print(&quot;Ya casi es fin de semana&quot;)
  case .Viernes:
    print(&quot;Por fin es viernes!!&quot;)
  case .Sabado:
    print(&quot;Y ya es fin de semana&quot;)
}
</code></pre>

<h4 id="casos-particulares-con-los-enums">Casos particulares con los Enums</h4>

<p>Los Enums tienen valores por omisión y ese valor es un entero.</p>

<pre><code class="language-swift">enum EstadoDocumento: Int {
  case Recibido = 0, Validado, EnProceso, Publicado
}

let valorEstado = EstadoDocumento.Validado.rawValue //Imprime: 1, con rawvalue se saca el valor en crudo

let estado = EstadoDocumento(rawValue: 2) //Imprime EnProceso. Con esto podemos sacar un valor de estado documento con su valor en crudo

let estado2 = EstadoDocumento(rawValue: 4) //estado2 es de tipo opcional, porque no hay garantia. En este caso es nil.

</code></pre>

<p>En el caso anterior, particularmente en el &lsquo;estado2&rsquo;, normalmente esto puede llegar a suceder cuando datos externos a la aplicación quieren acceder al Enum dentro de nuestra aplicación. Es decir, cuando recibimos una respuesta de un servicio, en general se recomienda tener una capa de seguridad que valide los datos recibidos y los apruebe para poder acceder a los datos de nuestra aplicación.</p>

<p>Para manejar el acceso a atributos que no existan como el caso de arriba, podemos validar los datos externos que recibimos.</p>

<pre><code class="language-swift">//Primero validamos que los datos se recibieron bien
enum ResultadoWebService {
  case Exito(String)
  case Error(Int)
}

func llamadaWs() -&gt; ResultadoWebService {
  if false { //Bandera de demostración que nunca será ejecutada en este caso
    return ResultadoWebService.Exito(&quot;Mi contenido&quot;)
  } else {
    return ResultadoWebService.Error(502)
  }
}

let resultado: ResultadoWebService = llamadaWs()

switch resultado {
  case let .Exito(contenido):
    print(contenido)
  case let .Error(codigo):
    print(&quot;El código de es es \(codigo)&quot;) //Imprime: &quot;El código de es es 502&quot;
}
</code></pre>

<h3 id="diccionarios">Diccionarios</h3>

<p>Diccionarios, mapas o colecciones asociativas</p>

<pre><code class="language-swift">var unDiccionario: [String:Int] = [:]
var diccionario = [&quot;llave1&quot;: 1, &quot;llave2&quot;: 2, &quot;llave3&quot;: 3]

//Dentro de unValor se guarda el valor anterior de la llave
//unValor es de tipo opcional
let unValor = diccionario.updateValue(4, forKey: &quot;llave2&quot;)
diccionario[&quot;llave1&quot;] = 10

//Si la llave no se encuentra, la va a crear
diccionario //Imprime:[&quot;llave1&quot;: 10, &quot;llave2&quot;: 4, &quot;llave3&quot;: 3]
diccionario[&quot;llavee&quot;] = 10
diccionario //Imprime: [&quot;llave1&quot;: 10, &quot;llavee&quot;: 10, &quot;llave2&quot;: 4, &quot;llave3&quot;: 3]
</code></pre>

<p>Diccionarios con llaves nulas</p>

<pre><code class="language-swift">//Cuando una llave es nula, la quita del mapa
//No se recomienda borrar llaves de esta manera

diccionario[&quot;llave3&quot;] = nil
diccionario //Imprime: [&quot;llave2&quot;: 4, &quot;llavee&quot;: 10, &quot;llave1&quot;: 10]

//Si se quiere remover una llave, se recomienda removerla de esta manera:

let llave2 = diccionario.removeValue(forKey:&quot;llave1&quot;)
diccionario.removeValue(forKey:&quot;llave2&quot;)
diccionario // Imprime: [&quot;llavee&quot;: 10]
</code></pre>

<h3 id="conjuntos">Conjuntos</h3>

<p>Declaración de conjuntos:</p>

<pre><code class="language-swift">//colecciones no ordenadas
var amigos = Set&lt;String&gt;()
var amigos1: Set&lt;String&gt; = [] //Si se inicializa
var amigos2 = Set([&quot;Julieta&quot;, &quot;Violeta&quot;, &quot;Andres&quot;, &quot;Ernesto&quot;])
var amigos3: Set = [&quot;Fabian&quot;, &quot;Freddy&quot;, &quot;Andres&quot;, &quot;Ernesto&quot;]
</code></pre>

<p>Algunas funciones con conjuntos:</p>

<pre><code class="language-swift">amigos3.insert(&quot;Julian&quot;) //Imprime: (inserted true, memberAfterInsert &quot;Julian&quot;)
amigos3.remove(&quot;Ernesto&quot;)
//No acepta duplicados
//Regresar una inserción falsa si se inserta un duplicado
amigos3.insert(&quot;Julian&quot;) //Imprime: (inserted false, memberAfterInsert &quot;Julian&quot;)

let estaVacio = amigos3.isEmpty //Imprime: false
let estaAndres = amigos3.contains(&quot;Andres&quot;) //Imprime: true
let numeroAmigos = amigos3.count //Imprime: 4

//Intersecciones, diferencia de intersecciones y la union

let comunes = amigos2.intersection(amigos3) //Imprime: {&quot;Andres&quot;}
let diferencias = amigos2.symmetricDifference(amigos3) //Imprime: {&quot;Ernesto&quot;, &quot;Julieta&quot;, &quot;Fabian&quot;, &quot;Freddy&quot;, &quot;Julian&quot;, &quot;Violeta&quot;}
let todos = amigos2.union(amigos3) //Imprime: {&quot;Freddy&quot;, &quot;Violeta&quot;, &quot;Fabian&quot;, &quot;Julieta&quot;, &quot;Julian&quot;, &quot;Ernesto&quot;, &quot;Andres&quot;}
let resta = amigos2.subtract(amigos3) //Imprime: ()
let resta2 = amigos2.subtracting(amigos3) //Imprime: {'Julieta', 'Violeta', 'Ernesto'}
</code></pre>

<p>Iterando conjuntos:</p>

<ul>
<li>No hay que perder de vista que no hay garantía de orden</li>
</ul>

<pre><code class="language-swift">for amigo in amigos3 {
  print(&quot;\(amigo) es mi amigo&quot;)
}
</code></pre>

<h3 id="estructuras">Estructuras</h3>

<p>Las estructuras no soportan herencia, si se habla de estructuras es porque estamos pasando copias.</p>

<p>La declaración de una estructura:</p>

<pre><code class="language-swift">struct Cuerpo {
  var altura: Double = 0
  var peso: Double = 0
}
</code></pre>

<h3 id="clases">Clases</h3>

<p>La declaración de una clase:</p>

<pre><code class="language-swift">class Persona {
  var cuerpo: Cuerpo = Cuerpo()
}
</code></pre>

<p>Las clases tienen un inicializador en lugar de contructor:</p>

<pre><code class="language-swift">var cuerpo = Cuerpo()
cuerpo.altura = 1.85
cuerpo.peso = 70

//Se crea una copia para Juan no se hace referencia, en el caso de la estructura Cuerpo
var juan = Persona()
juan.cuerpo = cuerpo
cuerpo.altura = 1.85
cuerpo.peso = 70
print(&quot;Juan es \(juan.cuerpo.altura) metros alto y pesa \(juan.cuerpo.peso)&quot;) //Imprime: &quot;Juan es 1.85 metros alto y pesa 70.0&quot;
print(cuerpo) //Imprime: &quot;Cuerpo(altura: 1.85, peso: 70.0)&quot;
</code></pre>

<p>La herencia se declara con dos puntos:</p>

<pre><code class="language-swift">//Empleado hereda de persona
class Empleado: Persona {
  var idEmpleado = 0
}

var empleado = Empleado()
empleado.cuerpo = cuerpo
empleado.idEmpleado = 2
</code></pre>

<h3 id="propiedades-almacenadas-y-calculadas">Propiedades almacenadas y calculadas</h3>

<p>El valor de las propiedades calculadas no se guardan en memoria simplemente se calculan .</p>

<pre><code class="language-swift">struct Cuerpo {
  var altura: Double = 1.73 //propiedades con almacenamiento y valor por default
  var peso: Double = 75
}

class Persona {
  var cuerpo: Cuerpo1 = Cuerpo1()
  var bmi: Double {
    get {
      return (cuerpo.peso/(cuerpo.altura * cuerpo.altura)) //propiedad calculada
    }
  }
}

var persona = Persona()
persona.cuerpo = Cuerpo()
print(&quot;El bmi de la persona es: \(persona.bmi)&quot;)
</code></pre>

<p>Las propiedades en las clases:</p>

<pre><code class="language-swift">class Empresa {
  var numeroEmpleados: Int = 0 {
    willSet { //Monitoreando u observando si una propiedad cambia, se ejecutara antes de que yo cambie el valor de la propiedad
      print(&quot;Tenemos \(numeroEmpleados) y vamos a tener \(newValue) empleado&quot;) // swift sintetiza e inclye newValue
    }
    didSet { //Depsues de que el cambio se hizo
      print(&quot;Ahora tenemos \(numeroEmpleados) y teniamos \(oldValue) empleados&quot;) // el valor previo que se tenia
    }
  }
}
</code></pre>

<h3 id="protocolos">Protocolos</h3>

<p>Es el mismo concepto de la interfaz. Describe las firmas y las clases implementan el contrato que esta especificandose en este protocolo.</p>

<p>Los protocolos también pueden heredar de otro protocolo.</p>

<pre><code class="language-swift">protocol EventoType {
  var titulo: String {get set}
  var id: Int {get}
  func creaNotificacionLocal()
}

class EventoCalendario: EventoType {
  var titulo: String = &quot; &quot;
  var id: Int = 0
  func creaNotificacionLocal(){
    //Algo aqui
  }
}

//Herencia de protocolos
protocol EventoEspecialType: EventoType {
  var esEspecial: Bool {get}
}
</code></pre>

<h3 id="closures">Closures</h3>

<pre><code class="language-swift">let numbers = [2,1,31,3,56,42,14]

func compareAscending(i: Int, j: Int) -&gt; Bool{
  print(&quot;i: \(i) &lt; j: \(j)&quot;)
  return i &lt; j
}

//Sorted es una funcion de orden superior
//Las funciones también es un tipo de dato
//Pueda pasar o devolver una funcion y esas se llaman de orden superior

let sortedNumbers = numbers.sorted(by: compareAscending) //Sorted funciona a traves de una funcion, toma la funcion y los ordena

//Funcion anonima
let sortedNumberAnonima = numbers.sorted(by: {
  (i: Int, j:Int) -&gt; Bool in
  return i &lt; j
})

let mappedNumbers = numbers.map { // recibe una funcion
  (i: Int) -&gt; Int in //se puede cambiar por string y retornar simplemante el &quot;valor&quot;
  //return &quot;\(1*2)&quot;
  return i * 3
}
mappedNumbers
</code></pre>

<pre><code class="language-swift">//Ejemplo de clouser
typealias myFunction = (String) -&gt; () //se crea un aleas para hacer mas legible el código

func reatPrint (times: Int) -&gt; myFunction { //De vuelve una funcion (La funcion devuelve void) Es una fabrica de funciones
  func printer(text: String) { // retiene el valor de una variable que ya debio de ser destruida, esto es una operacion de cerradura
    for _ in 1...times {
      print(text)
    }
  }
  return printer
}

let log = reatPrint(times: 5)
let log2 = reatPrint(times: 2)
log(&quot;Yeah&quot;)
log2(&quot;Ok&quot;)
</code></pre>

<h3 id="genéricos">Genéricos</h3>

<p>Los genéricos son funciones que reciben cualquier tipo de dato, según los datos que se le manden y dependiendo de la función.</p>

<pre><code class="language-swift">//Va a trabajar con un tipo de dato llamado T, no necesariamente tiene que ser una letra
func makePair&lt;T&gt;(x: T, y: T) -&gt; (T, T) {
  return (x,y)
}

let firstPair = makePair(x: 1, y: 2)
let secondPair = makePair(x: &quot;uno&quot;, y: &quot;dos&quot;)
//El compilador en tiempo de compilacion, reemplaza T por el tipo de dato que le estoy mandando
//se convierte en una especie de template
</code></pre>

<p>Con más de un atributo:</p>

<pre><code class="language-swift">func makePairDifferent&lt;T,U&gt;(x: T, y: U) -&gt; (T, U) {
  return (x,y)
}

let firstPairDifferent = makePairDifferent(x: 1, y: &quot;dos&quot;)
</code></pre>

<blockquote>
<p>Se recomienda que siempre sea declaren las funciones de manera simple, las funciones entre más simples mejor. Solo si después se requiere pueden llegar a ser genéricas, pero de entrada siempre tienen que ser simples.</p>
</blockquote>

<h3 id="manejo-de-errores">Manejo de errores</h3>

<p>La forma más sencilla de declarar una función que puede generar un error:</p>

<pre><code class="language-swift">func miFuncion() throws {}
</code></pre>

<p>La palabra try no significa que comenzará un bloque, en su lugar significa que esa línea puede generar una excepción.</p>

<pre><code class="language-swift">try miFuncion()
</code></pre>

<p>Se pueden colocar varios try dentro del bloque do</p>

<pre><code class="language-swift">do {
  try miFuncion()
} catch {
  print(error)
}
</code></pre>

<p>Ejemplo de manejo de errores con Enums:</p>

<pre><code class="language-swift">enum MiError: Error { //Los Enums pueden implementar protocolos
  case Malo
  case Peor
  case MuchoPeor
}

func infalible(val: Int) -&gt; String {
  return &quot;perfecto&quot;
}

func falible(error: Bool) throws -&gt; String {
  if error {
    throw MiError.Peor
  }
  return &quot;Casi perfecto&quot;
}

//En la lógica vemos que se puede manejar como switch

do {
  infalible(val: 2)
  try falible(error: true)
  print(&quot;Todo bien&quot;)
} catch MiError.Malo {
  print(&quot;Mal&quot;)
} catch MiError.Peor {
  print(&quot;Peor&quot;)
} catch MiError.MuchoPeor{
  print(&quot;Corraaaaan&quot;)
}

//try! falible(error: true) //Error en ejecucion
//try falible(error: true) //Error en compilacion
try? falible(error: true) //Como opcional
</code></pre>

          </div>

          
          <div class="row">
            <div class="col-md-8">
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=/post/libros/ class="post-meta">Previous
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>Libros 2019</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=/post/rust/ class="post-meta">Next
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>Rust</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="https://github.com/KarlaJu " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    

    

    

    
        <a href="https://twitter.com/KarlaJuJ" target="_blank" rel="noopener"><i class="fab fa-twitter mr-3" aria-hidden="true"></i></a>
    

    
        <a href="https://www.instagram.com/acoralay/" target="_blank" rel="noopener"><i class="fab fa-instagram mr-3" aria-hidden="true"></i></a>
    

    


    
        <a href="mailto:karla@makingdevs.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2019 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



  
  <script src="/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="/js/vendors/katex/katex.min.js"> </script>
  <script src="/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>